#!/bin/python
import os
import struct
import sys
from collections import OrderedDict
import csv
from io import StringIO

sys.path.append(os.path.join(os.path.dirname(__file__), 'common'))
from common import utils, tilesets
from sw2gb import cutscene

script_name = sys.argv[0]
output_file = sys.argv[1]
input_asm = sys.argv[2]

def parse_line(cs, references, line):
    # [Command] [Parameters]
    data = [x.strip('\n') for x in line.split(' ', 1) if x]
    assert 0 < len(data) <= 2
    command = cs.COMMANDS[data[0]]
    parameters = []
    if len(data) == 2:
        d = StringIO(data[1])
        c = csv.reader(d, lineterminator='', delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
        parameters += next(c)

    # Convert values to integers
    # Note that we explicitly use a while loop
    # because we may dynamically adjust the size of the loop
    idx = 0
    while idx < len(parameters):
        if parameters[idx].startswith('$'):
            parameters[idx] = int(parameters[idx].lstrip('$'), 16)
        elif parameters[idx].startswith('.') and cs.is_branch(command.command_byte):
            # offset is 2 bytes, so we need to insert 2 bytes in little endian format
            offset = references[parameters[idx]] if parameters[idx] in references else 0
            parameters[idx] = offset & 0xFF
            parameters.insert(idx + 1, ((offset >> 8) & 0xFF))
            idx += 1
        idx += 1

    to_write = [command.command_byte] + command.write_handler(*parameters)

    return (command.name, parameters, to_write)

bank = None
addr = None
cs_name = None
lines = []
references = {}
with open(input_asm, 'r', encoding='utf-8') as fp:
    bank = int(next(fp).lstrip('; '), 16)
    addr = int(next(fp).lstrip('; '), 16)
    cs_name = next(fp).strip().rstrip(':')
    assert bank >= 0x41, "Banks are expected to be offset from $41"
    assert addr >= 0x4000 and addr < 0x8000, "Initial addresses must be within 0x4000 and 0x7FFF"

    # Load tileset info
    character_table = tilesets.get_tileset("CutsceneScript", override_offset=0x00)
    cs = cutscene.CutsceneScript(character_table)

    # Split the work into two passes:
    # 1. Gather every reference
    # 2. Properly note the instruction
    current_offset = 0
    for line in fp:
        line = line.strip()
        if line.startswith(';'):
            continue

        if line.startswith('.'):
            references[line] = current_offset
            continue
        to_write = None
        try:
            (_, _, to_write) = parse_line(cs, references, line)
        except Exception as e:
            print(f"Error at line: {line}, error: {e}")
            exit(1)
        current_offset += len(to_write)

    fp.seek(0)
    next(fp)
    next(fp)
    next(fp)
    for line in fp:
        line = line.strip()
        if line.startswith('.') or line.startswith(';'):
            continue
        (name, parameters, to_write) = parse_line(cs, references, line)
        lines.append((name, parameters, to_write))
        current_offset += len(to_write)

with open(output_file, 'w', encoding='utf-8') as ofp:
    ofp.write(f'; File autogenerated by {script_name}\n')

    overflow_count = 0
    overflow_bytes = []
    remaining_bytes = 0
    for idx, line in enumerate(lines):
        if remaining_bytes == 0:
            ofp.write(f'\nSECTION "{cs_name} {overflow_count}", ROMX[${addr:04X}], BANK[${bank + overflow_count:02X}]\n')
            ofp.write(f'{cs_name}_{overflow_count}::\n')
            if len(overflow_bytes) > 0:
                ofp.write(f'  db {",".join([f"${x:02X}" for x in overflow_bytes]) } ; Previous command overflow\n')
            remaining_bytes = 0x8000 - addr

        (name, parameters, to_write) = line

        # Check if the remaining bytes can handle the parameters + command byte
        if remaining_bytes - len(to_write) <= 0:
            overflow_bytes = to_write[remaining_bytes:]
            to_write = to_write[:remaining_bytes]
            addr = 0x4000
            overflow_count += 1
        remaining_bytes -= len(to_write)
        ofp.write(f'.{name}_{idx:02X} ; {",".join([f"${x:02X}" if type(x) is int else x for x in parameters])}\n')
        ofp.write(f'  db { ",".join([f"${x:02X}" for x in to_write]) }\n')